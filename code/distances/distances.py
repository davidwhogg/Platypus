# coding: utf-8

""" Interpolate absolute magnitudes from the PARSEC isochrones """

from __future__ import division, print_function

__author__ = "Andy Casey <arc@ast.cam.ac.uk>"

# Standard library
from glob import glob

# Third party
import numpy as np
import scipy.interpolate


def load_parsec_isochrone(filename):

    # Load the relevant information from the isochrone filename

    """
    # File generated by CMD 2.5 (http://stev.oapd.inaf.it/cmd) on Wed Jan  8 16:38:19 CET 2014
    # PARSEC isochrones, release v1.1
    # Basic reference: Bressan et al. (2012), MNRAS, 427, 127
    # Warning: the TP-AGB phase is not included! TP-AGB tracks are in preparation by Marigo et al.
    # Photometric system:  2MASS <i>JHK</i><sub>s</sub>
    # BCs of Carbon stars derive from Loidl et al. (2001, A&A 342, 531)
    # O-rich circumstellar dust ignored
    # C-rich circumstellar dust ignored
    # IMF: Chabrier (2001) lognormal 
    # On RGB, assumed Reimers mass loss with efficiency eta=0.2
    # Kind of output: isochrone tables
    #   Isochrone  Z = 0.01210  Y = 0.27040 [M/H] = -0.089  eta_R = 0.200   Age =   1.0000e+09 yr
    #      Z    log(age/yr) M_ini       M_act   logL/Lo logTe   logG    mbol    J       H       Ks  int_IMF stage
        0.012100    9.0000  0.10000000  0.1000  -2.9005 3.5040  5.3005  12.021  10.125  9.580   9.342   1.57040203  0
    """


    # We require: Teff, Logg, J, H, K
    # We will arrange it like this though: (J, H, K, Teff, logg) because
    # that will make things easier later
    isochrone_data = np.loadtxt(filename, usecols=(8, 9, 10, 5, 6))

    # Parse the overall metallicity as well:
    with open(filename, 'r') as fp:
        # There are cleverer ways to do this
        content = fp.readlines()

    try:
        feh = float(content[11].split()[10])
    except:
        feh = float(content[12].split()[10])

    # Put this as a column to the data array
    feh_column = np.array([feh] * len(isochrone_data)).reshape(-1, 1)
    isochrone_data = np.hstack([isochrone_data, feh_column])
    return isochrone_data


def load_all_parsec_isochrones(filenames):

    # Need to create one big array which we will use for interpolation
    all_isochrone_data = []
    [all_isochrone_data.extend(load_parsec_isochrone(filename)) for filename in filenames]

    # Array-ify the data
    all_isochrone_data = np.array(all_isochrone_data)

    # Need to split it into points and values
    # Points are the data we have: teff, logg, feh
    # Values are what we want to interpolate (J, H, K)

    values = all_isochrone_data[:, :3] # J, H, K
    points = all_isochrone_data[:, 3:] # teff, logg, feh

    return (points, values)


class MagnitudeInterpolator(object):

    def __init__(self, filenames):
        points, values = load_all_parsec_isochrones(filenames)

        # Convert logarithmic quantities to linear space
        # log(Teff), log(g), [Fe/H]
        points = 10**points

        # J, H, K are all logarithms
        values = 10**values

        self.interpolator = scipy.interpolate.LinearNDInterpolator(points, values)


    def __call__(self, point):
        """ Interpolate absolute uncertainties for a point (teff, logg, [M/H]) """

        # Teff already linear
        # Convert logg, feh to linear
        point[1] = 10**point[1]
        point[2] = 10**point[2]
        absolute_magnitudes = self.interpolator(*point)

        # Convert the absolute magnitudes (which are linear) back to logarithmic
        # space
        return np.log10(absolute_magnitudes)


    def pdf(self, point, uncertainties, size=100):
        """ Get a PDF of magnitudes for a given point with uncertainties """

        teff, logg, feh = point
        u_teff, u_logg, u_feh = uncertainties

        teff_pdf = np.random.normal(teff, u_teff, size)
        logg_pdf = np.random.normal(logg, u_logg, size)
        feh_pdf = np.random.normal(feh, u_feh, size)

        magnitude_distributions = np.zeros((size, 3))
        magnitude_distributions[:]

        for i, (teff_i, logg_i, feh_i) in enumerate(zip(teff_pdf, logg_pdf, feh_pdf)):
            point_i = [teff_i, logg_i, feh_i]
            magnitude_distributions[i, :] = self(point_i)

        q = lambda v: (v[1], v[2] - v[1], v[1] - v[0])

        quantiles = []
        for i in range(3):
            quantiles.append(q(np.percentile(magnitude_distributions[:, i], [16, 50, 84])))

        return quantiles


if __name__ == "__main__":

    """
    # Create an interpolator
    magnitudes = MagnitudeInterpolator(glob("isochrones/PARSEC*.dat"))

    # Example: Some set of stellar parameters:
    teff, logg, feh = [5777., 4.445, 0.]
    j_absolute, h_absolute, k_absolute = magnitudes([teff, logg, feh])

    print("For Teff = {0:.0f}, logg = {1:.2f}, [Fe/H] = {2:.2f} absolute magnitudes are:"
        " J = {3:.2f}, H = {4:.2f}, K = {5:.2f}".format(teff, logg, feh, j_absolute,
            h_absolute, k_absolute))

    # Example: Propagate symmetric uncertainties in stellar parameters:
    teff, logg, feh = [5000, 2.2, -1]
    u_teff, u_logg, u_feh = [250, 0.2, 0.1]

    print("For Teff = {0:.0f} +/- {1:.0f} K, logg = {2:.2f} +/- {3:.2f}, [Fe/H] = {4:.2f} +/- {5:.2f}:".format(
        teff, u_teff, logg, u_logg, feh, u_feh))

    bands = "JHK"

    # Since we don't have posterior distributions and we just have a mean and standard
    # deviation, we will approximate this as a gaussian and sample it N times
    pdf = magnitudes.pdf([teff, logg, feh], [u_teff, u_logg, u_feh])

    for band, quantiles in zip(bands, pdf):
        print(" {0} = {1:.2f} +/- (+{2:.2f}, -{3:.2f})".format(band, quantiles[0], quantiles[1], quantiles[2]))

    """

    magnitudes = MagnitudeInterpolator(glob("isochrones/PARSEC*.dat"))

    # Example: Some set of stellar parameters:
    teff, logg, feh = [5777., 4.445, 0.]
    j_absolute, h_absolute, k_absolute = magnitudes([teff, logg, feh])

    print("With 1 Gyr isochrones..")
    print("For Teff = {0:.0f}, logg = {1:.2f}, [Fe/H] = {2:.2f} absolute magnitudes are:"
        " J = {3:.2f}, H = {4:.2f}, K = {5:.2f}".format(teff, logg, feh, j_absolute,
            h_absolute, k_absolute))



    magnitudes = MagnitudeInterpolator(glob("isochrones/ness*.dat"))
    teff, logg, feh = [5777., 4.445, 0.]
    j_absolute, h_absolute, k_absolute = magnitudes([teff, logg, feh])

    print("With 10 Gyr isochrones..")
    print("For Teff = {0:.0f}, logg = {1:.2f}, [Fe/H] = {2:.2f} absolute magnitudes are:"
        " J = {3:.2f}, H = {4:.2f}, K = {5:.2f}".format(teff, logg, feh, j_absolute,
            h_absolute, k_absolute))


    with open("testandy.txt", "r") as fp:
        lines = fp.readlines()[1:]

    rows = []
    for line in lines:
        teff, logg, feh, k_apparent, A_k = map(float, line.split())

        j_absolute, h_absolute, k_absolute = magnitudes([teff, logg, feh])

        k_corrected = k_apparent - max([A_k, 0])
        mu = k_corrected - k_absolute
        distance = 10**(1 + mu/5.0)
        distance /= 1000. # in kpc

        rows.append({
            "Teff": teff,
            "logg": logg,
            "[Fe/H]": feh,
            "K_apparent": k_apparent,
            "A_k": A_k,
            "J_absolute": j_absolute,
            "H_absolute": h_absolute,
            "K_absolute": k_absolute,
            "Distance": distance
        })

    from astropy.table import Table

    results = Table(rows=rows)
    results.write("results.csv")



    
